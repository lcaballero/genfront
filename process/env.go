package process

import (
	"bytes"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"strings"

	"path/filepath"

	"github.com/lcaballero/genfront/cli"
	"github.com/lcaballero/genfront/maybe"
	"github.com/spf13/viper"
)

const sep = "--------------------------------------------------------------------------------\n"

const (
	goArch    = "GOARCH"
	goOS      = "GOOS"
	goFile    = "GOFILE"
	goLine    = "GOLINE"
	goPackage = "GOPACKAGE"
	dollar    = "DOLLAR"
	cwd       = "CWD"
	tagline   = "GEN_TAGLINE"
	args      = "ARGS"
)

const (
	mainPackage = "main"
)

// Env contains values needed when executing the template that were gathered
// from the environment.
type Env struct {
	pairs map[string]interface{}
}

// NewEnv creates a new Env
func NewEnv() *Env {
	env := &Env{
		pairs: make(map[string]interface{}),
	}
	env.AddGoEnvironment()
	return env
}

// ToMap provides the Env instance as a map[string]interface{} for use as data
// when executing a template.
func (e *Env) ToMap() map[string]interface{} {
	return e.pairs
}

// Add puts the value in the map with the given key.
func (e *Env) Add(key string, val interface{}) *Env {
	e.pairs[key] = val
	return e
}

// AddPairs adds all of the pairs in the map to the Env instance.
func (e *Env) AddPairs(pairs map[string]interface{}) *Env {
	for k, v := range pairs {
		e.Add(k, v)
	}
	return e
}

// AddYaml adds the objects as parsed from the frontmatter string.
func (env *Env) AddYaml(frontmatter string) (*Env, error) {
	v := viper.New()
	v.SetConfigType("yaml")
	err := v.ReadConfig(bytes.NewBufferString(frontmatter))
	env.AddPairs(v.AllSettings())
	return env, err
}

// String finds the value associated with the key, and if it is a string
// returns the string value, else it returns the string value provided as
// the default.
func (env *Env) String(key, def string) string {
	g, ok := env.pairs[key]
	if !ok {
		return def
	}
	s, ok := g.(string)
	if ok {
		return s
	} else {
		return def
	}
}

// Codefile finds the .go file based on the GOFILE environment variable, else
// it uses the provided parameter: defaultGoFile.
func (env *Env) Codefile(defaultGoFile string) string {
	cwd := env.String(cwd, "")
	gofile := env.String(goFile, defaultGoFile)
	return filepath.Join(cwd, gofile)
}

// RelativeFile creates a path to the file relative to the current working
// directory.
func (env *Env) RelativeFile(f string) string {
	cwd := env.String(cwd, "")
	return filepath.Join(cwd, f)
}

// Exists check if the given file exists and returns true if it does and
// false otherwise.
func (env *Env) Exists(file string) bool {
	if _, err := os.Stat(file); os.IsNotExist(err) {
		return false
	}
	return true
}

// AddGoEnvironment adds all of the environment values provided by go when
// running go:generate.
func (env *Env) AddGoEnvironment() *Env {
	var govars = []string{
		goArch,
		goOS,
		goFile,
		goLine,
		goPackage,
		dollar,
	}

	for _, e := range govars {
		env.Add(e, os.Getenv(e))
	}

	if p, ok := env.pairs[goPackage]; !ok || p == "" {
		env.Add(goPackage, mainPackage)
	}

	wd, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	env.Add(cwd, wd)
	env.Add(tagline, fmt.Sprintf("// Generated by %s -- do not edit this file.", os.Args[0]))
	env.Add(args, os.Args)

	return env
}

// BuildFuncMap adds a number of functions that can be used when executing
// a template.
func (env *Env) BuildFuncMap() template.FuncMap {
	return template.FuncMap{
		"pascal":    ToPascal,
		"title":     strings.Title,
		"lower":     strings.ToLower,
		"upper":     strings.ToUpper,
		"toSymbol":  ToSymbol,
		"getenv":    os.Getenv,
		"split":     strings.Split,
		"camelCase": ToCamelCase,
		"hasPrefix": strings.HasPrefix,
	}
}

// CreateTemplate creates a template after it builds and adds a function map
// based on the given tpl file,
func (env *Env) CreateTemplate(tpl string) (*template.Template, error) {
	return template.New("FrontMatterProcessor").Funcs(env.BuildFuncMap()).Parse(tpl)
}

// sep is for debug, separating output into sections of concerns
func (e *Env) sep() string {
	return strings.Repeat("-", 80)
}

// MaybeExit is used to conditionally exit before executing the template based
// on the 'no op' (noop) flag.
func (p *Env) MaybeExit(conf *cli.CliConf, tpl *template.Template, content string) {
	if conf.Debug() {
		p.ShowDebug(conf, tpl, content)
	}
	if conf.Noop() {
		log.Printf("Skipping writing output file: %s", maybe.JoinCwd(conf.OutputFile()))
		os.Exit(1)
	}
}

// ShowEnvironment outputs this Env to the Writer, if any errors were gathered
// and provided to this function they too will be written to standard out.
func (env *Env) ShowEnvironment(w io.Writer, errs ...error) {
	for k, v := range env.pairs {
		fmt.Fprintf(w, "%s : %s\n", k, v)
	}

	for i, e := range os.Args {
		fmt.Fprintf(w, "os.Args[%d] = %s\n", i, e)
	}

	if errs == nil || len(errs) == 0 {
		return
	}

	for _, err := range errs {
		fmt.Fprintln(w, err)
	}
}

// ShowDebug will output debug information to stdout.
func (p *Env) ShowDebug(conf *cli.CliConf, tpl *template.Template, content string) {
	w := os.Stdout
	fmt.Fprint(w, sep)
	p.ShowEnvironment(w)
	fmt.Fprint(w, sep)
	fmt.Fprintln(w, conf)
	fmt.Fprint(w, sep)

	if tpl != nil {
		err := tpl.Execute(w, p.ToMap())
		if err != nil {
			fmt.Fprint(err.Error())
		}
	}

	if content != "" {
		fmt.Fprint(w, content)
	}

	fmt.Fprintln(w)
}
